Patch by MSP-Greg
Added -a --assert parameter for test-all
a) turns on verbose
b) adjusts assertions count so that tests, regardless of manner run, show similar results.
c) adds assertion total by test to each line of output
diff --git a/tool/lib/minitest/unit.rb b/tool/lib/minitest/unit.rb
index c85b41e5fc..c1c60fa6fd 100644
--- a/tool/lib/minitest/unit.rb
+++ b/tool/lib/minitest/unit.rb
@@ -3,7 +3,7 @@
 
 require "optparse"
 require "rbconfig"
-require "leakchecker"
+require_relative "../leakchecker"
 
 ##
 # Minimal (mostly drop-in) replacement for test-unit.
@@ -756,6 +756,7 @@ class Unit # :nodoc:
     attr_accessor :start_time                         # :nodoc:
     attr_accessor :help                               # :nodoc:
     attr_accessor :verbose                            # :nodoc:
+    attr_accessor :assert                             # :nodoc:
     attr_writer   :options                            # :nodoc:
 
     ##
@@ -900,8 +901,8 @@ def _run_anything type
 
         results = _run_suites suites, type
 
-        @test_count      = results.inject(0) { |sum, (tc, _)| sum + tc }
-        @assertion_count = results.inject(0) { |sum, (_, ac)| sum + ac }
+        @test_count      = results.sum { |i| i[0] }
+        @assertion_count = results.sum { |i| i[1] }
         test_count      += @test_count
         assertion_count += @assertion_count
         t = Time.now - start
@@ -910,7 +911,8 @@ def _run_anything type
           puts
           puts
         end
-        puts "Finished%s %ss in %.6fs, %.4f tests/s, %.4f assertions/s.\n" %
+        ret = options[:assert] ? "\n" : ""
+        puts "#{ret}Finished%s %ss in %.6fs, %.4f tests/s, %.4f assertions/s.\n" %
              [(@repeat_count ? "(#{@@current_repeat_count}/#{@repeat_count}) " : ""), type,
                t, @test_count.fdiv(t), @assertion_count.fdiv(t)]
       end while @repeat_count && @@current_repeat_count < @repeat_count &&
@@ -934,6 +936,7 @@ def _run_anything type
     #
 
     def _run_suites suites, type
+      @assert = @options[:assert]
       suites.map { |suite| _run_suite suite, type }
     end
 
@@ -955,19 +958,41 @@ def _run_suite suite, type
 
       leakchecker = LeakChecker.new
 
+      verbose = options[:verbose]
+      retry_run = options[:retry_run]
+      retry_len = retry_run.to_s.length if retry_run
+      assert_offset = 0
+
+      if self.assert # && options[:retry_run]
+        zombie   = (defined?(ZombieHunter)      && ZombieHunter.is_a?(Module)     ) ? -2 : 0
+        tracepnt = (defined?(TracePointChecker) && TracePointChecker.is_a?(Module)) ? -1 : 0
+        assert_offset = zombie + tracepnt
+      end
+
       continuation = proc do
         assertions = filtered_test_methods.map { |method|
           inst = suite.new method
-          inst._assertions = 0
+          inst._assertions = assert_offset
 
-          print "#{suite}##{method} = " if @verbose
-
-          start_time = Time.now if @verbose
+          start_time = verbose ? Time.now : nil
           result = inst.run self
 
-          print "%.2f s = " % (Time.now - start_time) if @verbose
-          print result
-          puts if @verbose
+          if start_time
+            ttl = " = %.2f s = " % (Time.now - start_time)
+            if !self.assert # || MetaMetaMetaTestCase === inst.class.superclass
+              print "#{suite}##{method}#{ttl}#{result}"
+            elsif retry_run
+              @cntr ||= 0
+              @cntr += 1
+              print "[#{@cntr.to_s.rjust(retry_len)}/#{retry_run}] #{inst._assertions.to_s.rjust(6)} #{suite}##{method}#{ttl}#{result}"
+            else
+              print "#{inst._assertions.to_s.rjust(6)} #{suite}##{method}#{ttl}#{result}"
+              print @parallel_error if @parallel_error
+            end
+            print "\n"
+          else
+            print result
+          end
           $stdout.flush
 
           unless defined?(RubyVM::MJIT) && RubyVM::MJIT.enabled? # compiler process is wrongly considered as leak
@@ -976,7 +1001,8 @@ def _run_suite suite, type
 
           inst._assertions
         }
-        return assertions.size, assertions.inject(0) { |sum, n| sum + n }
+
+        return assertions.size, assertions.sum
       end
 
       if ENV["LEAK_CHECKER_TRACE_OBJECT_ALLOCATION"]
@@ -1005,6 +1031,9 @@ def _run_suite suite, type
     # error or failure.
 
     def record suite, method, assertions, time, error
+      @parallel_error = (error && !options[:retry_run]) ?
+        "\n       #{location error}\n       #{error.message.gsub "\n", "\n       "}" :
+        nil
     end
 
     def location e # :nodoc:
@@ -1027,7 +1056,7 @@ def puke klass, meth, e
       e = case e
           when MiniTest::Skip then
             @skips += 1
-            return "S" unless @verbose
+            return "S" unless @verbose || options[:hide_skip] == false
             "Skipped:\n#{klass}##{meth} [#{location e}]:\n#{e.message}\n"
           when MiniTest::Assertion then
             @failures += 1
@@ -1045,6 +1074,7 @@ def initialize # :nodoc:
       @report = []
       @errors = @failures = @skips = 0
       @verbose = false
+      @assert = false
       @mutex = Thread::Mutex.new
       @info_signal = Signal.list['INFO']
       @repeat_count = nil
@@ -1079,6 +1109,11 @@ def process_args args = [] # :nodoc:
           options[:verbose] = true
         end
 
+        opts.on '-a', '--assert', "Adjust & show assertions numbers" do
+          options[:verbose] = true
+          options[:assert]  = true
+        end
+
         opts.on '-n', '--name PATTERN', "Filter test names on pattern (e.g. /foo/)" do |a|
           options[:filter] = a
         end
@@ -1096,6 +1131,8 @@ def process_args args = [] # :nodoc:
       srand options[:seed]
 
       self.verbose = options[:verbose]
+      self.assert  = options[:assert]
+
       @help = orig_args.map { |s| s =~ /[\s|&<>$()]/ ? s.inspect : s }.join " "
 
       options
diff --git a/tool/lib/test/unit.rb b/tool/lib/test/unit.rb
index 376ca8d3d4..1fdc2204f9 100644
--- a/tool/lib/test/unit.rb
+++ b/tool/lib/test/unit.rb
@@ -3,11 +3,11 @@
   gem 'minitest', '< 5.0.0' if defined? Gem
 rescue Gem::LoadError
 end
-require 'minitest/unit'
-require 'test/unit/assertions'
+require_relative '../minitest/unit'
+require_relative 'unit/assertions'
 require_relative '../envutil'
 require_relative '../colorize'
-require 'test/unit/testcase'
+require_relative 'unit/testcase'
 require 'optparse'
 
 # See Test::Unit
@@ -95,7 +95,14 @@ def setup_options(opts, options)
 
         opts.on '-v', '--verbose', "Verbose. Show progress processing files." do
           options[:verbose] = true
-          self.verbose = options[:verbose]
+          self.verbose = true
+        end
+
+        opts.on '-a', '--assert', "Adjust & show assertions numbers" do
+          options[:verbose] = true
+          options[:assert]  = true
+          self.verbose = true
+          self.assert  = true
         end
 
         opts.on '-n', '--name PATTERN', "Filter test method names on pattern: /REGEXP/, !/REGEXP/ or STRING" do |a|
@@ -470,7 +477,6 @@ def _run_parallel suites, type, result
           warn "Error: parameter of -j option should be greater than 0."
           return
         end
-
         # Require needed thing for parallel running
         require 'timeout'
         @tasks = @files.dup # Array of filenames.
@@ -531,7 +537,12 @@ def _run_parallel suites, type, result
             suites.map! {|r| eval("::"+r[:testcase])}
             del_status_line or puts
             unless suites.empty?
-              puts "\n""Retrying..."
+              puts "\nRetrying..."
+              if @options[:retry]
+                ttl_count = 0
+                suites.each { |s| ttl_count += s.public_instance_methods(true).grep(/^test/).length }
+                @options[:retry_run] = ttl_count
+              end
               _run_suites(suites, type)
             end
             @options[:parallel] = parallel
@@ -548,7 +559,7 @@ def _run_parallel suites, type, result
             if @options[:retry]
               @errors   += rep.map{|x| x[:result][0] }.inject(:+)
               @failures += rep.map{|x| x[:result][1] }.inject(:+)
-              @skips    += rep.map{|x| x[:result][2] }.inject(:+)
+              @skips    += rep.map{|x| x[:result][2] }.inject(:+) unless @options[:parallel]
             end
           end
           unless @warnings.empty?
@@ -608,7 +619,7 @@ def setup_options(opts, options)
 
       def _run_suites(suites, type)
         result = super
-        report.reject!{|r| r.start_with? "Skipped:" } if @options[:hide_skip]
+        report.reject! {|r| r.start_with? "Skipped:" } if @options[:hide_skip]
         report.sort_by!{|r| r.start_with?("Skipped:") ? 0 : \
                            (r.start_with?("Failure:") ? 1 : 2) }
         failed(nil)
@@ -722,6 +733,7 @@ def output
       end
 
       def _prepare_run(suites, type)
+        @assert = options[:assert]
         options[:job_status] ||= :replace if @tty && !@verbose
         case options[:color]
         when :always
@@ -1146,13 +1158,17 @@ def puke klass, meth, e
         # TODO:
         #   this overriding is for minitest feature that skip messages are
         #   hidden when not verbose (-v), note this is temporally.
-        n = report.size
-        rep = super
-        if MiniTest::Skip === e and /no message given\z/ =~ e.message
-          report.slice!(n..-1)
-          rep = "."
+        if options[:hide_skip] == false
+          super
+        else
+          n = report.size
+          rep = super
+          if MiniTest::Skip === e and /no message given\z/ =~ e.message
+            report.slice!(n..-1)
+            rep = "."
+          end
+          rep
         end
-        rep
       end
     end
 
diff --git a/tool/lib/tracepointchecker.rb b/tool/lib/tracepointchecker.rb
index 3254e59357..87aa027aa8 100644
--- a/tool/lib/tracepointchecker.rb
+++ b/tool/lib/tracepointchecker.rb
@@ -1,4 +1,9 @@
 # frozen_string_literal: true
+
+# The assertions called in after_teardown are offset in minitest/unit.rb
+# so that assertions counts with and with this are the same.  If the count
+# changes, please adjust the code in unit.rb, search for tracepnt
+
 module TracePointChecker
   STATE = {
     count: 0,
diff --git a/tool/lib/zombie_hunter.rb b/tool/lib/zombie_hunter.rb
index 33bc467941..dad1e04758 100644
--- a/tool/lib/zombie_hunter.rb
+++ b/tool/lib/zombie_hunter.rb
@@ -1,5 +1,9 @@
 # frozen_string_literal: true
 
+# The assertions called in after_teardown are offset in minitest/unit.rb
+# so that assertions counts with and without this are the same.  If the
+# count changes, please adjust the code in unit.rb, search for zombie
+
 module ZombieHunter
   def after_teardown
     super
